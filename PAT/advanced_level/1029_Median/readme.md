##  20180803更新

*   PAT从旧平台搬迁到pintia后，有很多莫名其妙的问题(比如PAT_A_1055等题目无法通过)，然后有些题目提问和条件也改了(如PAT_A_1029)

    本题的提问和条件已改，内存限制为1.5MB，而N最大可以达到2x10^5, 元素宽度在long int之内
    
    pintia平台是64位的机器，编译器是 `gcc 6.4.0/g++ 6.4.0`, long int 占 4 个 Byte
    
    仅考虑填满一个数组，极限情况是 2 x 10^5 x 4 B = 0.8 x 10^6 B ≈ 0.8 MB   (如果按照long int = 8 Byte, 那么更容易爆)
    
    可见如果申请两个这样大小的数组，那肯定要爆内存了。所以我们得用其他方法
    
*   如果不考虑内存限度，那么最快的方法就是开一个大数组，把所有数字读进来，然后用快排，最后输出下标为 [lenA + lenB - 1] / 2 的元素

    这样可以拿到14分(根据新的AC答案，本题总分16分)

    ```cpp
    void fun(){
      vector<int> seq;
      int lenA, lenB, val;
    	
    	cin>>lenA;
    	for( int i = 0; i < lenA; i++ ){
    		cin>>val;
    		seq.push_back(val);
    	}
    	
    	cin>>lenB;
    	for( int i = 0; i < lenB; i++ ){
    		cin>>val;
    		seq.push_back(val);
    	}
    	
    	sort(seq.begin(), seq.end());
    	cout<<seq[ (lenA + lenB - 1) / 2 ]<<'\n';
    }
    ```

*   稍微修改一下原来的方法2(双指针)，我们可以拿到15分

    题目修改后，我们主要需要节约使用内存。其实如果题目一开始就给出n和m，那就没必要开数组了，直接用原来的方法2(双指针)的方法
    
    现在，我们只能省下数组b的存储空间。
    
    也就是边读取边判断, 方法2原来是这样的
    
    ```cpp
    while( k < mid ){
		if( a[i] < b[j] ){
			i++;
		}else{
			j++;
		}
		k++;
	}
    ```
    
    现在我们可以这样, 临时变量 val 用于读取第二行数组的输入, 然后j作为移动的下标
    
    ```cpp
    int val;
	cin>>val;
	while( k < mid ){
		if( i < len1 && v1[i] < val ){
			i++;
		}else{
			j++;
			if( j < len2 ){
				cin>>val;
			}
		}
		k++;
	}
    ```
    
    15分的完整代码请参考 `median_3.cpp`, 剩下的1分是case6没通过, 应该是边界问题(因为在14分的暴力解法中是通过了的)。不过，这个解法使用的是int而非long int, 所以case6也有可能出现了long int导致溢出。
    
    如果有同学找到了边界问题，欢迎发issue或者pr ^_^
    
*   另附某个大佬写的AC答案, 请查看 `median_4_AC_20180803.cpp`

---

##  原来的readme

寻找中位数

1.	两个数组都是排好序的，用归并排序，合并两个数组，然后输出中位数
2.	数组c原来是用于保存归并后的结果的，其实可以不要，我们只要找到下标就好了。（补充：将两个数组最后一个元素设为INF，防止while时某个数组溢出）

注意

*	中位数下标是`(lenA + lenB - 1)/2`，不是`(lenA + lenB)/2`，否则只能拿一半的分数

*	方法1和方法2，时间差不多，因为1中做了N次赋值，在2中做了N次判断，时间其实差不多。不过2比1少一半的内存（因为不需要数组c了）。
